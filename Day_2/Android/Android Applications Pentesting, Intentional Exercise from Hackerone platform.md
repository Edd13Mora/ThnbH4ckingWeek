
# Presentation

Today we are going to practice some android pentesting with challenge made by Hackerone platform.

I'll explain different techniques used in Android pentesting with a practical overview.

This article was made for the day2 of the hack event organised by The hacking News B'Darija.


# Challenge

We can access the challenege using https://ctf.hacker101.com/ctf 

# Intentional Exercise Challenge setup


https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/

```
**Your Android APK is building. Please refresh in a few seconds.**
```
```
https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/level13.apk
```

https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting

# Instal the apk using Bluestackes

I didn't have time to setup a clean emulor inside my linux machine so i just use my windows machine with Bluestacks emulator. It's probably simple to setup the proxy with it right ? :')

After installing the app we can see it in your app menu.


![Pasted image 20220727190015](https://user-images.githubusercontent.com/72421091/181377629-016547e2-769e-4b96-b82e-06b7b2a04a4f.png)



## Proxy setup with burp

We need to set the proxy used by bluestackes using HD-ConfigHttpProxy.exe. You can find it in your apllication installation.

![Pasted image 20220727190717](https://user-images.githubusercontent.com/72421091/181377657-fbd62f1c-999e-433c-9fa7-ae8c1811cbb7.png)


Now let's add our burp proxy

![Pasted image 20220727202122](https://user-images.githubusercontent.com/72421091/181377676-a84012ad-11b9-49fa-a70d-7f93de9ac276.png)


After setting a proxy, you need to restart bluestacks. You can use the reset option to back to default.

Now we need to :
- Use BlueStacks Tweaker to root the emulator.
- Install root certificate manager from google play store.
- Import the burp certificate. You can export it from proxy tab.

# Intercept requests while opening the app

Before the app shows the webview we can see a request to `https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot?&hash=61f4518d844a9bd27bb971e55a23cd6cf3a9f5ef7f46285461cf6cf135918a1a`

![Pasted image 20220727202844](https://user-images.githubusercontent.com/72421091/181378693-c9a67583-9443-439b-8d50-278c0ef219d3.png)


Here is the response : 
```http
HTTP/1.1 200 OK
Date: Wed, 27 Jul 2022 19:29:48 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 64
Connection: close
Server: openresty/1.21.4.1

<h1>Welcome to Level13</h1><a href="appRoot/flagBearer">Flag</a>
```

After frowarding the requests let's see what happen afer clicking "Flag"

![Pasted image 20220727203135](https://user-images.githubusercontent.com/72421091/181377835-ffd71fa7-1ea6-48e5-ad1d-feba7f61226c.png)

We can see a new request to /appRoot/flagBearer same output from our first request. After forwarding the request we can an ouput with Invalid request 

![Pasted image 20220727203253](https://user-images.githubusercontent.com/72421091/181377854-3f23d74d-72a6-47a8-a473-183f762e4d4a.png)


Here is the response : 

```http
HTTP/1.1 200 OK
Date: Wed, 27 Jul 2022 19:32:18 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 15
Connection: close
Server: openresty/1.21.4.1

Invalid request
```

Now let's try to analyze what we able to find :
- Leaked the used domain : 86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com
- Hash parametre with /appRoot : hash=61f4518d844a9bd27bb971e55a23cd6cf3a9f5ef7f46285461cf6cf135918a1a
- openresty/1.21.4.1 : Web server version. 
- The app maybe trying to verify a hash token with /appRoot to access/appRoot/flagBearer which is our final access.
- We can check the links with our browser, It's seems like the app is usinf a webview. We can get the same behavior
- 
![Pasted image 20220727204544](https://user-images.githubusercontent.com/72421091/181377885-2f6ccc84-7785-457d-8ad6-7d8529e2189a.png)




We did some testing with the app now let's switch to some reversing with the apk file.

# What is an apk file ?

A file with the APK file extention is an Android Package file that's used to distribute apps on Google's Android operating system

APK files are saved in the ZIP format and are typically downloaded directly to Android devices, usually via Google Play, but can also be found on other websites.

# APKLeaks

There is a tool called APKLeaks it help for getting urls, endpoints and secrets from our apk files. It's used by bug bounty hunters https://github.com/dwisiswant0/apkleaks

![Pasted image 20220727214356](https://user-images.githubusercontent.com/72421091/181377965-2ab932d0-227d-4fcc-a4c1-1d910c22bfda.png)

As we can see there some android xml files and the domain used with a endpoint /appRoot.

And after that you be like emm some juicy cash money for my bug bounty report.


![Pasted image 20220727213844](https://user-images.githubusercontent.com/72421091/181378000-3ec55722-307f-4d9a-ae97-40020ed492ef.png)

# Apktool

It's a tool for reverse engineering Android apk files. We are going to use it to extract files from our apk. You can check the documentaion to have more details https://ibotpeaches.github.io/Apktool/

You can see instructions here to install it 

As i'm using Kali linux there a package for it. We can use apt to install  `sudo apt install apktool`

Let's extract the apk file 

![Pasted image 20220727210300](https://user-images.githubusercontent.com/72421091/181378192-017067a5-c5f2-4a3a-8d8c-4779e1c62388.png)

![Pasted image 20220727210635](https://user-images.githubusercontent.com/72421091/181378221-5b062c81-f451-41dd-bd7b-c3d6477f6ff7.png)


- The AndroidManifest.xml is important for security research, it's has the permisions required by the app and which can be abused if it's not configured proporl. We can read more about that  : 
  https://pentestlab.blog/2017/01/24/security-guidelines-for-android-manifest-files/ 
  https://www.briskinfosec.com/blogs/blogsdetail/Android-Manifest-File-Analysis-101

- Our focus today is the classes.dex file. The code is packed into .dex files. Dex stands for Dalvik Executable. A Dex file contains code that is ultimately executed by the Android Runtime. We can convert dex files to jar files using the dex2jar tool

![Pasted image 20220727211329](https://user-images.githubusercontent.com/72421091/181378236-c9664514-88dd-4b93-a3fb-49682ceaa967.png)

Now let's decompile the jar file using JD-GUI [http://java-decompiler.github.io/](http://java-decompiler.github.io/)

![Pasted image 20220727211659](https://user-images.githubusercontent.com/72421091/181378255-07897f33-0b34-449e-b1d1-8df799b4b6dd.png)

As we can see here the applications config details.

Now let's go to our target, the MainActivity.class. It's like the main code from our android app. We can read more about android app deveploment to have more details about it.

MainActivity.class
```java
package com.hacker101.level13;  
  
import android.net.Uri;  
import android.os.Bundle;  
import android.support.v7.app.AppCompatActivity;  
import android.webkit.WebView;  
import android.webkit.WebViewClient;  
import java.math.BigInteger;  
import java.nio.charset.StandardCharsets;  
import java.security.MessageDigest;  
import java.security.NoSuchAlgorithmException;  
  
public class MainActivity extends AppCompatActivity {  
  protected void onCreate(Bundle paramBundle) {  
    super.onCreate(paramBundle);  
    setContentView(2131296284);  
    WebView webView = (WebView)findViewById(2131165328);  
    webView.setWebViewClient(new WebViewClient());  
    Uri uri = getIntent().getData();  
    String str1 = "https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot";  
    String str3 = "";  
    if (uri != null) {  
      str3 = uri.toString().substring(28);  
      StringBuilder stringBuilder = new StringBuilder();  
      stringBuilder.append("https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot");  
      stringBuilder.append(str3);  
      str1 = stringBuilder.toString();  
    }   
    String str2 = str1;  
    if (!str1.contains("?")) {  
      StringBuilder stringBuilder = new StringBuilder();  
      stringBuilder.append(str1);  
      stringBuilder.append("?");  
      str2 = stringBuilder.toString();  
    }   
    try {  
      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");  
      messageDigest.update("s00p3rs3cr3tk3y".getBytes(StandardCharsets.UTF_8));  
      messageDigest.update(str3.getBytes(StandardCharsets.UTF_8));  
      byte[] arrayOfByte = messageDigest.digest();  
      BigInteger bigInteger = new BigInteger();  
      this(1, arrayOfByte);  
      String str = String.format("%064x", new Object[] { bigInteger });  
      StringBuilder stringBuilder = new StringBuilder();  
      this();  
      stringBuilder.append(str2);  
      stringBuilder.append("&hash=");  
      stringBuilder.append(str);  
      webView.loadUrl(stringBuilder.toString());  
    } catch (NoSuchAlgorithmException noSuchAlgorithmException) {  
      noSuchAlgorithmException.printStackTrace();  
    }   
  }  
}
```

# Now we have the source code what to do ?

![Pasted image 20220727212805](https://user-images.githubusercontent.com/72421091/181378309-fde968b3-55e1-4828-9157-d77762c8bfca.png)

It's just the app code for us x)

As we see from our first interaction with app http requests, we need to understand how to get the hash to access /appRoot/flagBearer or maybe use it for other things.

Start analyzing
- First we can see the libraires imported and used.
- The app set a webview to be able to see urls.
- Start to build a url insied URI class probably https://developer.android.com/reference/java/net/URI
We can see the code if URI is null 
```java
    if (uri != null) {  
      str3 = uri.toString().substring(28);  
      StringBuilder stringBuilder = new StringBuilder();  
      stringBuilder.append("https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot");  
      stringBuilder.append(str3);  
      str1 = stringBuilder.toString();  
    }
```
- str1 = "https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot";
- build the str2 with str1 + append "?"
- Try to do some fancy encryption for a string to convert it to a hash and build the final URL 
```java
    try {  
      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");  
      messageDigest.update("s00p3rs3cr3tk3y".getBytes(StandardCharsets.UTF_8));  
      messageDigest.update(str3.getBytes(StandardCharsets.UTF_8));  
      byte[] arrayOfByte = messageDigest.digest();  
      BigInteger bigInteger = new BigInteger();  
      this(1, arrayOfByte);  
      String str = String.format("%064x", new Object[] { bigInteger });  
      StringBuilder stringBuilder = new StringBuilder();  
      this();  
      stringBuilder.append(str2);  
      stringBuilder.append("&hash=");  
      stringBuilder.append(str);  
      webView.loadUrl(stringBuilder.toString());  
    } catch (NoSuchAlgorithmException noSuchAlgorithmException) {  
      noSuchAlgorithmException.printStackTrace();  
    }
```

If you can't understand what the code does, you can simply create a java code and start importing used libraries and print each line to see the output. We need to add the str variable and also set a URI value for testing

```java
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
class test {
    public static void main(String[] args) {
    // here we need to the add used URI and string values.
    // put the try catch and start analysing using System.out.println()
    }
    
    }
```

After doing some testing now let's back to our way to find the hash.
- for URI i abused the function that show how the URI is built if found it null
```java
    if (uri != null) {  
      str3 = uri.toString().substring(28);  
      StringBuilder stringBuilder = new StringBuilder();  
      stringBuilder.append("https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot");  
      stringBuilder.append(str3);  
      str1 = stringBuilder.toString();  
    }
```

as we can it does a substring 28 and take the last part

```java
class test {
    public static void main(String[] args) {
        String URI = "AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBB";
        System.out.println(URI.toString().substring(28));
        
        }
}
```
```
BBBBBBB
```

for the str1 we have an URL + str3 (URI.toString().substring(28))

```
https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot + str3
```

We use "BBBB" dor str3 at the moment. We can see that the beginnig is probably a "/"

Now str1 = https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot/BBBB

The str2 is str1 + "?"
```
https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot/BBBB?
```

At the encryption part we can see that the code append another &hash= and the hash value

```
      stringBuilder.append(str2);  
      stringBuilder.append("&hash=");  
      stringBuilder.append(str);
```
```
https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot/BBBB?hash=X
```

Looks familiar right ? if we back to our requests analysis at the beginning we can see the same format 

```
https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot?&hash=61f4518d844a9bd27bb971e55a23cd6cf3a9f5ef7f46285461cf6cf135918a1a
```

For the BBBB part it possible that it's flagBearer or maybe we can acces without it.

Now let's go for our solution. I used the same Main code with some modifications to get our hash. We can use online java compiler or from your system

```java
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


class HelloWorld {
    public static void main(String[] args) {
    String uri = "AAAAAAAAAAAAAAAAAAAAAAAAAAAA/flagBearer";
    String str1 = "https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot";
    String str3 = "";
    if (uri != null) {
      str3 = uri.toString().substring(28);
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot");
      stringBuilder.append(str3);
      str1 = stringBuilder.toString();
    } 
    String str2 = str1;
    if (!str1.contains("?")) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append(str1);
      stringBuilder.append("?");
      str2 = stringBuilder.toString();
    } 
    try {
      MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
      messageDigest.update("s00p3rs3cr3tk3y".getBytes(StandardCharsets.UTF_8));
      messageDigest.update(str3.getBytes(StandardCharsets.UTF_8));
      byte[] arrayOfByte = messageDigest.digest();
      BigInteger bigInteger = new BigInteger(1, arrayOfByte);
      String str = String.format("%064x", new Object[] { bigInteger });
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append(str2);
      stringBuilder.append("&hash=");
      stringBuilder.append(str);
      System.out.println(stringBuilder.toString());
    } catch (NoSuchAlgorithmException noSuchAlgorithmException) {
      noSuchAlgorithmException.printStackTrace();
    } 
  }
}
```

Output 

```
https://86c65fe0ecf5117f91f7d2eaf9adf25e.ctf.hacker101.com/appRoot/flagBearer?&hash=8743a18df6861ced0b7d472b34278dc29abba81b3fa4cf836013426d6256bd5e
```

Let's visit the url 

![Pasted image 20220727222124](https://user-images.githubusercontent.com/72421091/181378516-3d752cc4-9c1b-46ae-b975-0d5cdc23843a.png)

We were able to solve the challenge with right hash value.

# Conclusion


I hope you find this article useful. You can learn more Android applications pentesting, there is many interesting attacks. You can take a look at https://book.hacktricks.xyz/mobile-pentesting/android-app-pentesting  
